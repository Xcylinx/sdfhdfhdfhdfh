--<< CONFIGURATION >>--

local Config = {
    RejoinOnKick = true,
    WebSocketURL = "wss://lurk-cc.onrender.com",
    Key = "test",
}

--<< GAME LOAD >>--

if not game:IsLoaded() then
    game.Loaded:Wait()
end

--<< CONFIG CHECK >>--

local Config = Config

if not Config then
    warn("Configuration table is missing.")
    return
end

local RequiredConfigs = {}

for requiredValue, requiredType in pairs(RequiredConfigs) do
    local configValue = Config[requiredValue]

    if not configValue or type(configValue) ~= requiredType then
        warn("Missing required config value: " .. requiredValue)
        return
    end
end

Config = {
    RejoinOnKick = Config.RejoinOnKick or false,
    WebSocketURL = Config.WebSocketURL or "ws://localhost:3000/",
    Key = Config.Key
}

--<< PERFORM CLEANUP FUNCTION >>--

if getgenv().DisableLurk then
    pcall(getgenv().DisableLurk)
end

--<< SERVICES >>--

local Services = {
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    ContentProvider = game:GetService("ContentProvider"),
    TeleportService = game:GetService("TeleportService"),
    VirtualUser = game:GetService("VirtualUser"),
    HttpService = game:GetService("HttpService"),
    VirtualUser = game:GetService("VirtualUser"),
    RunService = game:GetService("RunService"),
    Workspace = game:GetService("Workspace"),
    CoreGui = game:GetService("CoreGui"),
    Players = game:GetService("Players")
}

--<< VARIABLES >>--

local LocalPlayer = Services.Players.LocalPlayer
local HostPlayer = nil

local WebSocketConnection = nil
local WebSocketFunctions = {}
local WebSocketActions = {}

local CommandFunctions = {}
local Functions = {}

local Connections = {}
local Whitelists = {}
local Commands = {}

local Variables = {}; do
    Variables.Unloaded = false

    Variables.ClientStatus = "Idle"
    Variables.ReconnectAttempts = 0
    Variables.MaxReconnectAttempts = 999
    Variables.ReconnectDelay = 5

    Variables.OtherClientPlayers = {}
    Variables.OtherClients = {}
end

--<< COMMAND FUNCTIONS >>--

CommandFunctions = {}; do
    function CommandFunctions.GetCommand(name)
        local Lowered = tostring(name):lower()

        for _, command in pairs(Commands) do
            if command.Name:lower() == Lowered then
                return command
            end

            for _, alias in pairs(command.Aliases) do
                if alias:lower() == Lowered then
                    return command
                end
            end
        end
    end

    function CommandFunctions.AddCommand(values)
        local RequiredValues = {
            Name = "string",
            Callback = "function"
        }

        for valueName, valueType in pairs(RequiredValues) do
            local value = values[valueName]

            if not value or type(value) ~= valueType then
                return false, "Missing required value: " .. valueName
            end
        end

        if CommandFunctions.GetCommand(values.Name) then
            return false, "Command already exists: " .. values.Name
        end

        Commands[values.Name] = {
            Name = values.Name,
            Aliases = values.Aliases or {},
            NoPrefix = values.NoPrefix or false,
            NoPermissions = values.NoPermissions or false,
            Callback = values.Callback,
            Parameters = values.Parameters or {}
        }

        return true
    end

    function CommandFunctions.RemoveCommand(name)
        Commands[Command.Name] = nil
    end

    function CommandFunctions.ExecuteCommand(command, arguments, author)
        return pcall(command.Callback, author, arguments)
    end

    function CommandFunctions.FilterCommandMessage(message)
        local HasPrefix = message:sub(1, #Config.Prefix) == Config.Prefix
        local WithoutPrefix = not HasPrefix and message or message:sub(#Config.Prefix + 1, #message)
        local Arguments = WithoutPrefix:split(" ")
        local CommandName = #Arguments > 0 and Arguments[1]
        local Command = CommandName and CommandFunctions.GetCommand(CommandName)

        table.remove(Arguments, 1)

        return Command, Arguments, HasPrefix
    end

    function CommandFunctions.IsWhitelisted(player)
        return Whitelists[player.Name] == true
    end

    function CommandFunctions.IsWhitelistPaused(player)
        return Whitelists[player.Name] == false
    end

    function CommandFunctions.WhitelistPlayer(player)
        if CommandFunctions.IsWhitelisted(player) then
            return false, "Player is already whitelisted"
        end

        Whitelists[player.Name] = true

        return true
    end

    function CommandFunctions.UnwhitelistPlayer(player)
        if not CommandFunctions.IsWhitelisted(player) then
            return false, "Player is not whitelisted"
        end

        Whitelists[player.Name] = nil

        return true
    end

    function CommandFunctions.ResumeWhitelist(player)
        if not CommandFunctions.IsWhitelisted(player) then
            return false, "Player is not whitelisted"
        end

        if not CommandFunctions.IsWhitelistPaused(player) then
            return false,  "Whitelist is not paused"
        end

        Whitelists[player.Name] = true

        return true
    end

    function CommandFunctions.PauseWhitelist(player, duration)
        if player == HostPlayer then
            return false, "Cannot pause whitelist for host"
        end

        if not CommandFunctions.IsWhitelisted(player) then
            return false, "Player is not whitelisted"
        end

        Whitelists[player.Name] = false

        if duration then
            task.spawn(function()
                local duration = tonumber(duration) or 60
                wait(duration)

                if CommandFunctions.IsWhitelistPaused(player) then
                    local Success, Response = CommandFunctions.ResumeWhitelist(player)

                    if Success then
                        print("Resumed whitelist for " .. player.Name .. " after " .. duration .. " seconds.")
                    else
                        print("Failed to resume whitelist for " .. player.Name .. ". Response: " .. tostring(Response))
                    end
                end
            end)
        end

        return true
    end

    function CommandFunctions.ConvertPlayerArgument(str, speaker, checks)
        local String = str and tostring(str)
        if not String then return end

        if String == "." or String:lower() == "me" then
            return speaker
        elseif String == "," then
            if not speaker then return end

            local Root = Functions.GetRoot(speaker)
            if not Root then return end

            local Closest = Functions.GetClosestPlayer(Root.Position, nil, exclude, checks)
            return Closest
        else
            return Functions.GetPlayer(String, {speaker, LocalPlayer})
        end
    end

    function CommandFunctions.HandleMessage(message, author, discord)
        if not message or (not author and not discord) then return end
        
        local Command, Arguments, HasPrefix = CommandFunctions.FilterCommandMessage(message)
        local Author = Services.Players:FindFirstChild(author)
        if not Author and not discord then return end

        if not Command or (not Command.NoPrefix and not HasPrefix) then
            return
        end

        if not discord and not CommandFunctions.IsWhitelisted(Author) and not Command.NoPermissions then
            return
        end
        
        if CommandFunctions.IsWhitelistPaused(Author) then
            warn(Author.Name .. " attempted to perform a command while their whitelist was paused.")

            return
        end

        if discord and Command.Parameters then
            if #Arguments < #Command.Parameters then
                return false, "Missing required parameters: " .. table.concat(Command.Parameters, ", ")
            end
        end

        local Success, Response = CommandFunctions.ExecuteCommand(Command, Arguments, Author)

        if not Success then
            warn(Command.Name .. " command failed to execute. Response: " .. tostring(Response))
        end
    end
end

--<< MAIN FUNCTIONS >>--

Functions = {}; do
    function Functions.GetConnection(name)
        return Connections[name]
    end

    function Functions.DisableConnection(name)
        local Connection = Functions.GetConnection(name)

        if not Connection then
            return false
        end

        pcall(function()
            Connection:Disconnect()
        end)

        Connections[name] = nil

        return true
    end

    function Functions.AddConnection(name, connection)
        Functions.DisableConnection(name)

        Connections[name] = connection
    end

    function Functions.IsKicked()
        local Success, Response = pcall(function()
            return Services.CoreGui.RobloxPromptGui.promptOverlay.ErrorPrompt.Visible
        end)

        return Success and Response or false
    end

    function Functions.OnKicked(Func)
        repeat wait() until Functions.IsKicked() or Variables.Unloaded

        if Variables.Unloaded or not Config.RejoinOnKick then
            return
        end

        return pcall(function()
            Func()
        end)
    end
end

--<< WEBSOCKET FUNCTIONS >>--

WebSocketFunctions = {}; do
    function WebSocketFunctions.SendData(data)
        if not WebSocketConnection then return end

        return pcall(function()
            WebSocketConnection:Send(Services.HttpService:JSONEncode(data))
        end)
    end

    function WebSocketFunctions.GetPlayerInfo(player)
        return {
            name = player.Name,
            displayName = player.DisplayName,
            userId = player.UserId
        }
    end

    function WebSocketFunctions.UpdatePlayerList()
        if not WebSocketConnection then return end

        local players = {}

        for _, v in pairs(Services.Players:GetChildren()) do
            if v ~= LocalPlayer then
                table.insert(players, v)
            end
        end

        task.spawn(function()
            pcall(function()
                WebSocketFunctions.SendData({
                    action = "player_list_update",
                    players = players,
                    jobId = game.JobId
                })
            end)
        end)
    end

    function WebSocketFunctions.SendStatus(status, details)
        if not WebSocketConnection then return end

        Variables.ClientStatus = status

        return WebSocketFunctions.SendData({
            action = "status_update",
            clientId = LocalPlayer.Name,
            status = status,
            details = details
        })
    end

    function WebSocketFunctions.HandleDisconnect()        
        Functions.DisableConnection("WebSocket Message")
        Functions.DisableConnection("WebSocket Close")
        
        WebSocketFunctions.ScheduleReconnect()
    end

    function WebSocketFunctions.SendInitialData()
        local CommandList = {}

        for name, command in pairs(Commands) do
            table.insert(CommandList, {
                name = name,
                description = command.Name,
                aliases = command.Aliases or {},
                parameters = command.Parameters or {}
            })
        end
        
        return WebSocketFunctions.SendData({
            action = "client_connect",
            clientId = LocalPlayer.Name,
            username = LocalPlayer.Name,
            displayName = LocalPlayer.DisplayName,
            status = "idle",
            placeId = game.PlaceId,
            jobId = game.JobId,
            key = Config.Key
        })
    end

    function WebSocketFunctions.SendCommandResult(command, success, response, color)
        return WebSocketFunctions.SendData({
            action = "command_result",
            client = LocalPlayer.Name,
            command = command,
            success = success,
            response = response,
            color = color
        })
    end

    function WebSocketFunctions.AddWebSocketAction(str, callback)
        WebSocketActions[str] = callback
    end

    function WebSocketFunctions.HandleWebSocketMessage(message)
        local Success, Response = pcall(function()
            return Services.HttpService:JSONDecode(message)
        end)

        if not Success then
            return false, "Failed to decode message: " .. tostring(message)
        end

        if not WebSocketActions[Response.action] then
            return false, "Invalid action: " .. tostring(Response.action)
        end

        return pcall(function()
            return WebSocketActions[Response.action](Response)
        end)
    end

    function WebSocketFunctions.ScheduleReconnect()
        if Variables.Unloaded then return end
        
        Variables.ReconnectAttempts += 1

        if Variables.ReconnectAttempts > Variables.MaxReconnectAttempts then
            warn("[!] Max reconnection attempts reached.")
            return
        end
        
        local Delay = Variables.ReconnectDelay * math.min(Variables.ReconnectAttempts, 3)
        print("Reconnecting in " .. Delay .. " seconds (Attempt " .. Variables.ReconnectAttempts .. "/" .. Variables.MaxReconnectAttempts .. ")")
        
        pcall(function()
            task.delay(Delay, WebSocketFunctions.Connect)
        end)
    end
    
    function WebSocketFunctions.Disconnect()
        if WebSocketConnection then
            pcall(function() WebSocketConnection:Close() end)
            WebSocketConnection = nil
        end
        
        for _, Connection in ipairs({"WebSocket Message", "WebSocket Close", "WebSocket Heartbeat"}) do
            Functions.DisableConnection(Connection)
        end
    end

    function WebSocketFunctions.Connect()
        if WebSocketConnection then
            pcall(function() WebSocketConnection:Close() end)
        end

        pcall(function()
            WebSocketConnection = WebSocket.connect(Config.WebSocketURL)
        end)

        if not WebSocketConnection then
            warn("[!] Failed to connect to WebSocket server.")
            return WebSocketFunctions.ScheduleReconnect()
        end

        print("[+] Successfully connected to WebSocket server.")
        Variables.ReconnectAttempts = 0

        if not WebSocketFunctions.SendInitialData() then
            warn("[!] Failed to send client data.")
            return WebSocketFunctions.ScheduleReconnect()
        end

        Functions.AddConnection("WebSocket Message", WebSocketConnection.OnMessage:Connect(function(message)
            local Success, Response = WebSocketFunctions.HandleWebSocketMessage(message)

            if not Success then
                warn("[!] Failed to perform action. Error: " .. tostring(Response))
            end
        end))

        Functions.AddConnection("WebSocket Close", WebSocketConnection.OnClose:Connect(function()
            WebSocketFunctions.HandleDisconnect()
        end))

        WebSocketFunctions.UpdatePlayerList()

        task.spawn(function()
            while Functions.GetConnection("WebSocket Message") do task.wait()
                if not WebSocketConnection then
                    continue
                end

                local Success = pcall(function()
                    WebSocketFunctions.SendData({
                        action = "heartbeat",
                        clientId = LocalPlayer.Name
                    })
                end)
                
                if not Success and not Variables.Unloaded then
                    WebSocketFunctions.Connect()
                end
                
                task.wait(30)
            end
        end)
    end
end

--<< LISTENERS >>--

task.spawn(Functions.OnKicked, function()
    Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
end)

--<< ANTI AFK >>--

do
    local Success, _ = pcall(function()
        local AmountDisabled = 0

        for i, v in next, getconnections(LocalPlayer.Idled) do
            v:Disable(); AmountDisabled += 1
        end

        if AmountDisabled == 0 then error() end
    end)

    if not Success then
        Functions.AddConnection("Anti Afk", LocalPlayer.Idled:Connect(function()
            Services.VirtualUser:CaptureController(); Services.VirtualUser:ClickButton2(Vector2.new())
        end))
    end
end

--<< DEFINE CLEANUP FUNCTION >>--

getgenv().DisableLurk = function()
    Variables.Unloaded = true

    for Connection, _ in pairs(Connections) do
        Functions.DisableConnection(Connection)
    end

    WebSocketFunctions.Disconnect()
end

--<< INITIALIZE WEBSOCKET >>--

WebSocketFunctions.AddWebSocketAction("execute_code", function(Data)
    if not Data.code then return end

    local Success, Response = pcall(function()
        return loadstring(Data.code)()
    end)

    if not Success then
        print("Error executing code:", Response)
    end
end)

WebSocketFunctions.AddWebSocketAction("update_clients", function(Data)
    if not Data or not Data.clients then return end

    Variables.OtherClients = Data.clients
    Variables.OtherClientPlayers = {}

    for _, v in ipairs(Variables.OtherClients) do
        if v ~= LocalPlayer.Name then
            table.insert(Variables.OtherClientPlayers, Services.Players:FindFirstChild(v))
        end
    end
end)

WebSocketFunctions.AddWebSocketAction("connection_confirmed", function(Data)
    WebSocketFunctions.SendData({
        action = "update_clients"
    })
end)

WebSocketFunctions.Connect()
